<meta charset="utf-8">
<p><a href="https://github.com/harfbuzz/harfbuzzjs">harfbuzzjs</a> demo. Supports font drag and drop.</p>
<p><input type="text" value="abc" id="text"></p>
<p><a id="svgResult"></a></p>
<p>Result:<div id="shapeResult"></div></p>
<script src="hbjs.js"></script> <!-- Wrapper, can be used without -->
<script>
'use strict';
var hb, fontBlob, fontUrl;
const fontScale = 1000;
function updateResult2() {
  var blob = hb.createBlob(fontBlob);
  var face = hb.createFace(blob, 0);
  var font = hb.createFont(face);
  font.setScale(fontScale, fontScale); // Optional, if not given will be in font upem

  var buffer = hb.createBuffer();
  buffer.addText(text.value);
  buffer.guessSegmentProperties();
  // buffer.setDirection('ltr'); // optional as can be by guessSegmentProperties also
  hb.shape(font, buffer); // features are not supported yet
  var result = buffer.json(font);

  // for (int i = 0; i < glyphCount; ++i) {
  //   GlyphMetrics metrics = getMetricsForGlyph(glyphInfo, glyphPositions, i, face_, font_, SCALE_FACTOR);

  //   // Running counts for height.
  //   yMin = std::min(yMin, double(metrics.y1));
  //   yMax = std::max(yMax, double(metrics.y2));

  //   // Running counts for width.
  //   xMin = std::min(xMin, double(metrics.x1 + xStart));
  //   // Note: Some glyphs, like space, have x1==x2==0, even though they have an actual width.
  //   // This is accounted for when a non-space character follows but breaks down for trailing
  //   // spaces. To account for this, assume the x origin is 0, and the x max is equal to the advance.
  //   // Use the freetype one, not harfbuzz, so we don't exclude kerning distances at the edges.
  //   double x2 = (metrics.x1 == 0 && metrics.x2 == 0) ? metrics.xAdvanceFT : metrics.x2;
  //   xMax = std::max(xMax, x2 + xStart);

  //   xStart += metrics.xAdvanceHB;
  // }

  // returns glyphs paths, totally optional
  var glyphs = {};
  var width = 0;
  result.forEach(function (glyph) {
    var xAdvance = glyph.ax;
    var xDisplacement = glyph.dx;
    var yDisplacement = glyph.dy;

    width += xAdvance;
  });

  buffer.destroy();
  font.destroy();
  face.destroy();
  blob.destroy();

  svgResult.innerHTML = `<svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style type="text/css">
      @font-face {
        font-family: the-font;
        src: url('` + fontUrl + `');
        font-weight: normal;
        font-style: normal;
      }
    .the-class { font: 36px the-font; }
    </style>
  </defs>

  <text x="0" y="100" class="the-class">` + text.value + `</text>
  <rect width="` + width / fontScale * 36 + `" height="100" style="fill:none;stroke-width:1.5;stroke:black" />
</svg>`;

  shapeResult.innerText = JSON.stringify({glyphs: result, width: width});
}

function getFontUrl(fontName, byteArray) {
  var ext = fontName.split('.').pop();
  console.log('Creating font for ' + fontName + ' with type ' + ext);
  if (ext === 'otf') {
    return URL.createObjectURL(new Blob([byteArray], { type: 'font/opentype' }))
  } else if (ext === 'ttf') {
    return URL.createObjectURL(new Blob([byteArray], { type: 'font/truetype' }))
  } else {
    throw Error('unknown font type ' + ext)
  }
}

// We could use instantiateStreaming but it's not supported in Safari yet
// https://bugs.webkit.org/show_bug.cgi?id=173105
fetch("hb.wasm").then(function (x) {
  return x.arrayBuffer();
}).then(function (wasm) {
  return WebAssembly.instantiate(wasm);
}).then(function (result) {
  result.instance.exports.memory.grow(400); // each page is 64kb in size
  window.hb = hbjs(result.instance);
  var initialFontName = 'Roboto.abc.ttf';
  fetch(initialFontName).then(function (res) {
    return res.arrayBuffer();
  }).then(function (blob) { // can be used without our wrapper
    window.fontBlob = new Uint8Array(blob);
    fontUrl = getFontUrl(initialFontName, window.fontBlob);
    updateResult2();
  });
});

document.getElementById('text').addEventListener('keyup', function(e) {
  updateResult2();
});

document.addEventListener('dragover', function (e) {
  e.stopPropagation(); e.preventDefault();
}, false);
document.addEventListener('dragleave', function (e) {
  e.stopPropagation(); e.preventDefault();
}, false);
document.addEventListener('drop', function (e) {
  e.stopPropagation(); e.preventDefault();
  handleFontUpdate(e.dataTransfer.files[0]);
});

function handleFontUpdate(file) {
  if (!file) return;
  var reader = new FileReader();
  reader.addEventListener("load", function () {
    window.fontBlob = new Uint8Array(reader.result);
    fontUrl = getFontUrl(file.name, window.fontBlob);
    updateResult2();
  });
  reader.readAsArrayBuffer(file);
}

</script>
